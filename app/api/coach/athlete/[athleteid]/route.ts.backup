// /app/api/coach/athlete/[athleteId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ athleteId: string }> }
) {
  try {
    const { athleteId } = await params
    
    // Validate athleteId
    const athleteIdNum = parseInt(athleteId)
    if (isNaN(athleteIdNum)) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid athlete ID' 
        },
        { status: 400 }
      )
    }

    // Initialize Supabase client
    const cookieStore = await cookies()
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return cookieStore.get(name)?.value
          },
          set(name: string, value: string, options: any) {
            try {
              cookieStore.set(name, value, options)
            } catch (error) {
              // Handle cookie setting errors
            }
          },
          remove(name: string, options: any) {
            try {
              cookieStore.set(name, '', { ...options, maxAge: 0 })
            } catch (error) {
              // Handle cookie removal errors
            }
          },
        },
      }
    )

    // Verify user authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Unauthorized' 
        },
        { status: 401 }
      )
    }

    // Get coach user from users table
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('id, name')
      .eq('auth_id', user.id)
      .single()

    if (userError || !userData) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'User not found' 
        },
        { status: 404 }
      )
    }

    // Verify user is an approved coach
    const { data: coachData, error: coachError } = await supabase
      .from('coaches')
      .select('id, coach_name')
      .eq('user_id', userData.id)
      .eq('status', 'approved')
      .single()

    if (coachError) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Not an approved coach' 
        },
        { status: 403 }
      )
    }

    console.log('üîç Coach', coachData.coach_name, 'accessing athlete', athleteId)

    // Verify coach has access to this athlete
    const { data: relationship, error: relationshipError } = await supabase
      .from('coach_athlete_relationships')
      .select(`
        id,
        permission_level,
        status,
        primary_coach,
        assigned_at,
        users!coach_athlete_relationships_athlete_id_fkey (
          id,
          name,
          email,
          ability_level,
          body_weight,
          units,
          gender,
          created_at
        )
      `)
      .eq('coach_id', coachData.id)
      .eq('athlete_id', athleteIdNum)
      .eq('status', 'active')
      .single()

    if (relationshipError || !relationship) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Athlete not found or not assigned to you' 
        },
        { status: 404 }
      )
    }

    const athlete = relationship.users
    if (!athlete) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Athlete data not found' 
        },
        { status: 404 }
      )
    }

    // Based on permission level, determine what data to return
    const hasEditAccess = ['edit', 'full'].includes(relationship.permission_level)
    const hasFullAccess = relationship.permission_level === 'full'

    // Get athlete's current program
    const { data: currentProgram, error: programError } = await supabase
      .from('programs')
      .select('id, program_number, generated_at, weeks_generated')
      .eq('user_id', athleteIdNum)
      .order('generated_at', { ascending: false })
      .limit(1)
      .single()

    // Get recent performance data (last 30 days)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    const { data: recentPerformance, error: performanceError } = await supabase
      .from('performance_logs')
      .select(`
        id,
        week,
        day,
        block,
        exercise_name,
        sets,
        reps,
        weight_time,
        rpe,
        completion_quality,
        quality_grade,
        logged_at
      `)
      .eq('user_id', athleteIdNum)
      .gte('logged_at', thirtyDaysAgo.toISOString())
      .order('logged_at', { ascending: false })
      .limit(100)

    // Get athlete's latest 1RMs (if coach has edit+ access)
    let oneRMs = null
    if (hasEditAccess) {
      const { data: oneRMData, error: oneRMError } = await supabase
        .from('latest_user_one_rms')
        .select('exercise_name, one_rm, recorded_at')
        .eq('user_id', athleteIdNum)
        .order('recorded_at', { ascending: false })

      oneRMs = oneRMData || []
    }

    // Get athlete's skills data (if coach has edit+ access)
    let skills = null
    if (hasEditAccess) {
      const { data: skillsData, error: skillsError } = await supabase
        .from('latest_user_skills')
        .select('skill_name, skill_level, recorded_at')
        .eq('user_id', athleteIdNum)
        .order('recorded_at', { ascending: false })

      skills = skillsData || []
    }

// Calculate training metrics
const totalSessions = recentPerformance?.length || 0
const avgRPE = totalSessions > 0 
  ? Math.round(((recentPerformance?.reduce((sum, log) => sum + (log.rpe || 0), 0) || 0) / totalSessions) * 10) / 10
  : 0

const avgQuality = totalSessions > 0
  ? Math.round(((recentPerformance?.reduce((sum, log) => sum + (log.completion_quality || 0), 0) || 0) / totalSessions) * 10) / 10
  : 0

    // Group performance by block
    const blockStats = recentPerformance?.reduce((acc: any, log) => {
      if (!acc[log.block]) {
        acc[log.block] = {
          sessions: 0,
          avgRPE: 0,
          avgQuality: 0,
          exercises: new Set()
        }
      }
      acc[log.block].sessions++
      acc[log.block].avgRPE += log.rpe || 0
      acc[log.block].avgQuality += log.completion_quality || 0
      acc[log.block].exercises.add(log.exercise_name)
      return acc
    }, {})

    // Calculate block averages
    Object.keys(blockStats || {}).forEach(block => {
      const stats = blockStats[block]
      stats.avgRPE = Math.round((stats.avgRPE / stats.sessions) * 10) / 10
      stats.avgQuality = Math.round((stats.avgQuality / stats.sessions) * 10) / 10
      stats.uniqueExercises = stats.exercises.size
      delete stats.exercises
    })

    // Get latest session date
    const lastSession = recentPerformance?.[0]
    const daysSinceLastSession = lastSession 
      ? Math.floor((Date.now() - new Date(lastSession.logged_at).getTime()) / (1000 * 60 * 60 * 24))
      : null

    console.log(`‚úÖ Retrieved detailed data for athlete ${athlete.name}`)

    return NextResponse.json({
      success: true,
      athlete: {
        id: athlete.id,
        name: athlete.name,
        email: hasFullAccess ? athlete.email : null, // Email only for full access
        abilityLevel: athlete.ability_level,
        bodyWeight: hasEditAccess ? athlete.body_weight : null,
        units: hasEditAccess ? athlete.units : null,
        gender: hasEditAccess ? athlete.gender : null,
        joinedAt: athlete.created_at
      },
      coachingDetails: {
        relationshipId: relationship.id,
        permissionLevel: relationship.permission_level,
        isPrimaryCoach: relationship.primary_coach,
        assignedAt: relationship.assigned_at,
        hasEditAccess,
        hasFullAccess
      },
      currentProgram: currentProgram ? {
        id: currentProgram.id,
        programNumber: currentProgram.program_number,
        generatedAt: currentProgram.generated_at,
        weeksGenerated: currentProgram.weeks_generated
      } : null,
      recentActivity: {
        totalSessions,
        avgRPE,
        avgQuality,
        daysSinceLastSession,
        lastSessionDate: lastSession?.logged_at || null,
        blockBreakdown: blockStats || {}
      },
      recentPerformance: recentPerformance?.slice(0, 20) || [], // Last 20 sessions for overview
      oneRMs: hasEditAccess ? oneRMs : null,
      skills: hasEditAccess ? skills : null,
      metadata: {
        dataScope: 'last_30_days',
        permissionLevel: relationship.permission_level,
        generatedAt: new Date().toISOString()
      }
    })

  } catch (error) {
    console.error('‚ùå Unexpected error in coach/athlete detail:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}
